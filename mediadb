#!/usr/bin/python3

import re
import sys
import os
import os.path
import argparse
import sqlite3

import pprint

def do_init():
	db = sqlite3.connect('./mediadb.db')

	db.execute('''CREATE TABLE resource (
		id    INTEGER PRIMARY KEY AUTOINCREMENT,
		type  INTEGER NOT NULL, -- 0 = dir, 1 = file
		name  TEXT NOT NULL,
		path  TEXT NOT NULL,
		title TEXT,             -- short description
		desc  TEXT               -- long description

		UNIQUE (name, path)
	)''')

	db.execute('''CREATE TABLE tag (
        id    INTEGER PRIMARY KEY,
        name  TEXT UNIQUE
    )''')

	db.execute('''CREATE TABLE rtag (
		res_id INTEGER NOT NULL,
        tag_id INTEGER NOT NULL,

		PRIMARY KEY (res_id, tag_id),
		FOREIGN KEY (res_id) REFERENCES resource (id) ON DELETE CASCADE,
		FOREIGN KEY (tag_id) REFERENCES tag      (id) ON DELETE CASCADE
    )''')

	db.commit()
	db.close()

def tpl_ext(params):
	def __tpl_ext(ctx):
		print(os.path.splitext(ctx['filename']))
		ext = os.path.splitext(ctx['filename'])[1]
		if ext != '':
			ext = ext[1:]

		return ext
		
	return __tpl_ext

def tpl_path(params):
	index = None
	if len(params) == 1:
		index = int(params[0])

	def __tpl_path(ctx):
		if index is None:
			return ctx['path']

		return os.path.split(ctx['path'])[index]

	return __tpl_path

def do_index():
	parser = argparse.ArgumentParser(description='')
	parser.add_argument('--path') 
	parser.add_argument('--mode') 
	parser.add_argument('--tags') 
	args = vars(parser.parse_args(sys.argv[2:]))
	print(args)

	path = os.path.abspath(os.path.expanduser(args['path']))
	mode = args['mode']

	# parsing tags
	# a tag is a mix of static string and dynamic parts
	#Â i.e: 'foo%(ext)s' => 'foo' + file extension
	#
	tags = {'static': [], 'dyn': []}
	for tag in args['tags'].split(','):
		tpls = []
		idx  = -1
		def template(m):
			nonlocal idx

			try:
				tpls.append(eval('tpl_' + m.group(1))(m.groups()[1:]))
			except NameError as e:
				raise Exception("tag '{0}': invalid '{1}' template".format(tag, m.group(1)))
			
			idx += 1
			return "{" + str(idx) + "}"

		(tag, count) = re.subn("%\(([^)\]]*)(?:\[([^\]]*)\])?\)s", template, tag.strip())
		if count == 0:
			tags['static'].append(tag)
		else:
			tags['dyn'].append((tag, tpls))
	print(args['tags'],"\n",tags)

	db = sqlite3.connect('./mediadb.db')
	c = db.cursor()

	# tags resolution (static ones only)
	c.execute("SELECT * FROM tag WHERE name IN ({0})".format(','.join(["'{0}'".format(x) for x in tags['static']])))
	dbtags = dict(c)

	for t in set(tags['static']).difference(dbtags.values()):
		c.execute('''INSERT INTO tag VALUES (NULL, ?)''', (t,))
		dbtags[c.lastrowid] = t
	db.commit()
	print(dbtags)
	print(path, mode)

	tagcache = {}
	for root, dirs, files in os.walk(path):
		if mode == 'file':
			for name in files:
				c.execute('''INSERT INTO resource VALUES (NULL, 1, ?, ?)''', (name, root))
				rid = c.lastrowid
				print(name, rid)

				for tid in dbtags.keys():
					c.execute('''INSERT INTO rtag VALUES (?,?)''', (rid, tid))

				ctx = {'filename': name, 'path': root}
				for tag, tpls in tags['dyn']:
					ntag = tag.format(*[tpl(ctx) for tpl in tpls])
					
					if not ntag in tagcache:
						c.execute("SELECT id FROM tag WHERE name = ?", (ntag,))
						res = c.fetchone()

						if res:
							tagcache[ntag] = res[0]
						else:
							c.execute('''INSERT INTO tag VALUES (NULL, ?)''', (ntag,))
							tagcache[ntag] = c.lastrowid

					c.execute('''INSERT INTO rtag VALUES (?, ?)''', (rid, tagcache[ntag]))


	db.commit()
	#db.rollback()
	db.close()

def do_search():
	pass

if __name__ == '__main__':
	print(sys.argv[1]);
	action = sys.argv[1]

	try:
		fun = eval('do_' + action)
	except NameError:
		print("Unknown *{0}* action".format(action))
		sys.exit(1)

	fun()

